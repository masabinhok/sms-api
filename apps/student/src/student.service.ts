import { Inject, Injectable, NotFoundException, BadRequestException, OnModuleInit, Logger } from '@nestjs/common';
import { PrismaService } from './prisma.service';
import { TransactionHelper } from '../../libs/utils/transaction.util';
import { CreateStudentProfileDto } from '../../libs/dtos/create-student-profile.dto';
import { UpdateStudentProfileDto } from '../../libs/dtos/update-student-profile.dto';
import { QueryStudentsDto } from '../../libs/dtos/query-students.dto';
import { ClientProxy, ClientKafka } from '@nestjs/microservices';
import { Prisma } from '../generated/prisma';
import { firstValueFrom } from 'rxjs';

@Injectable()
export class StudentService implements OnModuleInit {
  private readonly logger = new Logger(StudentService.name);

  constructor(
    @Inject('AUTH_SERVICE') private authClient: ClientProxy,
    @Inject('ACADEMICS_SERVICE') private academicsClient: ClientKafka,
    @Inject('ACTIVITY_SERVICE') private activityClient: ClientProxy,
    private prisma: PrismaService
  ){}

  async onModuleInit() {
    // Subscribe to reply topics from academics service
    this.academicsClient.subscribeToResponseOf('class.getById');
    await this.academicsClient.connect();
    this.logger.log('Student service connected to academics service');
  }

  async createStudentProfile(createStudentProfileDto: CreateStudentProfileDto) {
    // Validate that the class exists
    try {
      const classResponse = await firstValueFrom(
        this.academicsClient.send('class.getById', { id: createStudentProfileDto.classId })
      );
      
      if (!classResponse || !classResponse.class) {
        throw new BadRequestException(`Class with ID ${createStudentProfileDto.classId} not found`);
      }
    } catch (error) {
      throw new BadRequestException(`Failed to validate class: ${error.message}`);
    }

    // Ensure createdBy is set, throw error if missing
    if (!createStudentProfileDto.createdBy) {
      throw new BadRequestException('createdBy field is required');
    }

    // Create student - roll number will be auto-generated by database
    const student = await this.prisma.student.create({
      data: {
        fullName: createStudentProfileDto.fullName,
        dob: createStudentProfileDto.dob,
        email: createStudentProfileDto.email,
        gender: createStudentProfileDto.gender,
        classId: createStudentProfileDto.classId,
        guardianName: createStudentProfileDto.guardianName,
        guardianContact: createStudentProfileDto.guardianContact,
        address: createStudentProfileDto.address,
        createdBy: createStudentProfileDto.createdBy,
      },
    });

    // emit event for auth service to create login credentials for respective student
    this.authClient.emit('student.created', {
      studentId: student.id,
      fullName: student.fullName,
      dob: student.dob,
      email: student.email
    });

    // Log activity - student profile created
    this.activityClient.emit('activity.log', {
      userId: createStudentProfileDto.createdBy,
      userRole: createStudentProfileDto.createdByRole,
      action: 'CREATE',
      description: `Created student profile: ${student.fullName} (${student.email})`,
      entityType: 'STUDENT',
      entityId: student.id,
      metadata: {
        email: student.email,
        fullName: student.fullName,
        classId: student.classId,
        rollNumber: student.rollNumber,
        guardianName: student.guardianName,
        guardianContact: student.guardianContact,
      },
    });

    return student;
  }

  async getAllStudents(query: QueryStudentsDto) {
    const { page = 1, limit = 10, search, className, section, sortBy = 'createdAt', order = 'desc' } = query;
    
    const skip = (page - 1) * limit;

    // Build where clause for filtering
    const where: Prisma.StudentWhereInput = {};

    if (search) {
      where.OR = [
        { fullName: { contains: search, mode: 'insensitive' } },
        { email: { contains: search, mode: 'insensitive' } },
        { guardianName: { contains: search, mode: 'insensitive' } },
        { guardianContact: { contains: search, mode: 'insensitive' } },
      ];
    }

    if (className) {
      // className can now be used as classId filter
      where.classId = className;
    }

    // Note: section is removed from the schema

    // Build orderBy clause
    const orderBy: Prisma.StudentOrderByWithRelationInput = {
      [sortBy]: order,
    };

    // Get total count for pagination
    const total = await this.prisma.student.count({ where });

    // Get students with pagination
    const students = await this.prisma.student.findMany({
      where,
      orderBy,
      skip,
      take: limit,
    });

    return {
      data: students,
      meta: {
        total,
        page,
        limit,
        totalPages: Math.ceil(total / limit),
      },
    };
  }

  async getStudentById(id: string) {
    const student = await this.prisma.student.findUnique({
      where: { id },
    });

    if (!student) {
      throw new NotFoundException(`Student with ID ${id} not found`);
    }

    return student;
  }

  async updateStudent(id: string, updateStudentProfileDto: UpdateStudentProfileDto, userId: string, userRole: string) {
    // Check if student exists
    const existingStudent = await this.prisma.student.findUnique({
      where: { id },
    });

    if (!existingStudent) {
      throw new NotFoundException(`Student with ID ${id} not found`);
    }

    // Update student
    const updatedStudent = await this.prisma.student.update({
      where: { id },
      data: updateStudentProfileDto,
    });

    // Log activity - student profile updated
    this.activityClient.emit('activity.log', {
      userId: userId,
      userRole: userRole,
      action: 'UPDATE',
      description: `Updated student profile: ${updatedStudent.fullName}`,
      entityType: 'STUDENT',
      entityId: updatedStudent.id,
      metadata: {
        updates: updateStudentProfileDto,
      },
    });

    return updatedStudent;
  }

  async deleteStudent(id: string, userId: string, userRole: string) {
    // Check if student exists
    const existingStudent = await this.prisma.student.findUnique({
      where: { id },
    });

    if (!existingStudent) {
      throw new NotFoundException(`Student with ID ${id} not found`);
    }

    // Delete student within transaction
    await TransactionHelper.execute(this.prisma, async (tx) => {
      await tx.student.delete({
        where: { id },
      });
    });

    // Emit events after successful transaction
    this.authClient.emit('student.deleted', {
      studentId: id,
      email: existingStudent.email,
    });

    // Log activity - student profile deleted
    this.activityClient.emit('activity.log', {
      userId: userId,
      userRole: userRole,
      action: 'DELETE',
      description: `Deleted student profile: ${existingStudent.fullName} (${existingStudent.email})`,
      entityType: 'STUDENT',
      entityId: id,
      metadata: {
        deletedStudent: {
          fullName: existingStudent.fullName,
          email: existingStudent.email,
          classId: existingStudent.classId,
          rollNumber: existingStudent.rollNumber,
        },
      },
    });

    return { success: true, message: 'Student deleted successfully' };
  }

  async getStudentStats() {
    const total = await this.prisma.student.count();
    
    const byClass = await this.prisma.student.groupBy({
      by: ['classId'],
      _count: true,
    });

    const byGender = await this.prisma.student.groupBy({
      by: ['gender'],
      _count: true,
    });

    return {
      total,
      byClass,
      byGender,
    };
  }
}

